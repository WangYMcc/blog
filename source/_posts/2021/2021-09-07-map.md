---
title: Java HashMap
category: blog
tags: [Java]
excerpt: HashMap的学习总结
keywords: Map,HashTable,Java
---
## HashMap

HashMap是Java中最常用的键值对数据结构，其主要由数组+链表来实现的，Jdk1.8之后还加入红黑树的结构。下面我们来看看HashMap的主要属性：
```java
    public class HashMap<K,V> extends AbstractMap<K,V> implements Map<K,V>, Cloneable, Serializable {
        static final int DEFAULT_INITIAL_CAPACITY = 1 << 4; //默认初始容量
        static final int MAXIMUM_CAPACITY = 1 << 30; //最大容量
        static final float DEFAULT_LOAD_FACTOR = 0.75f;  //默认负载因子
        int threshold; //当前阈值，负载因子*数组大小
        final float loadFactor; //负载因子
        transient int size;  //当前容量
        transient Node<K,V>[] table;  //键值对的数组
        //.....
    }
```
HashMap的键值对是一个Node数组，它实现了Map接口的Entry接口，Node为HashMap的基本组成单元，Node为单向链表，下面展示Node的源码：
```java
    static class Node<K,V> implements Map.Entry<K,V> {
            final int hash;
            final K key;
            V value;
            Node<K,V> next;
    }
```
HashMap数组的每个元素初始值均为null

![avatar](/images/hashmap.jpg)

在JDK1.8以及之后的版本，当链表长度达到8时，会将链表转换成红黑树结构。

除此之外，HashMap还有四个构造器:
```$xslt
    public HashMap() {} //无参构造函数，使用默认负载因子和默认容量
    public HashMap(int initialCapacity) {} //带初始容量的构造函数，使用默认负载因子
    public HashMap(int initialCapacity, float loadFactor) {} ////带初始容量的构造函数和负载因子的构造函数
    public HashMap(Map<? extends K, ? extends V> m) {}  //带其他实现了Map接口的子类的构造函数，使用默认负载因子
```
除了最后一个构造函数创建的HashMap，其他的都会在第一次put的时候才会创建Node数组（调用的扩容方法）。put方法的实现如下：

1、将key做hash运算，由它的hashCode与它本身低16位做亦或操作，得到该key的hash值；然后判断table数组是否为空，也就是是否为第一次put；

2、若table数组为空，则进行扩容，如果不为空跳到第3步。

&emsp;&emsp;1）扩容的机制很简单，如果当前容量大于最大容量，将阈值置为Int最大值，直接返回旧数组；

&emsp;&emsp;2）如果当前容量扩容之后小于最大容量，将阈值和数组长度都扩容两倍，并将原数组的元素转移到新数组并返回新数组；（这里有种特殊情况，当扩容后的数组长度小于16时，阈值不变）

&emsp;&emsp;3）如果当前容量为0且阈值不为0，即为第一次put，使用默认容量和传入的阈值构建数组；

&emsp;&emsp;4）如果当前容量为0且阈值为0，即为第一次put，使用默认容量和默认阈值构建数组；

3、获取key的下标，index = (数组长度-1)&hash；如果当前下标为空，直接构建Node节点放在头部。如果下标不为空，且key值相等，则将该key的val替换。如果是链表结构，直接加到链表尾部，而且如果长度>=8，还会转换为红黑树。如果是红黑树，则转换为TreeNode节点并加到叶子节点。

4、key-val添加或替换之后，返回旧值；如果是下标为空直接添加Node节点在头部的情况，则modCount++，并判断是否重新扩容，返回旧值为null。

HashMap的Get方法的实现也很简单，首先通过hash运算得到key的下标位置index，然后判断当前下标是否为空，如果为空直接返回null，如果不为空则依次判断该链表或者红黑树是否存在该key，存在则返回val，不存在则返null。

## 扩展

compute(key, BiFunction<? super K, ? super V, ? extends V> remappingFunction)：该方法不管key是否存在，都会调用remappingFunction计算之后得到新value，如果key存在且value不是null时将旧值替换，如果value为null则移除该节点（key不存在且value不为null则新增）。

computeIfAbsent(key, BiFunction<? super K, ? super V, ? extends V> mappingFunction)：当key也不存在或者为null时，才会调用mappingFunction执行后得到的value，然后新增节点并返回value。（value存在则不调用直接返回value）

computeIfPresent(key, BiFunction<? super K, ? super V, ? extends V> remappingFunction)：当key存在，才会调用remappingFunction计算之后得到新的value，如果value为null会将节点删除并返回null，如果value不为null则会替换value值并返回value。

putIfAbsent(K key, V value)：如果当前key不存在，将key-value插入到数组中并返回null（如果key存在且value为null，也会替换并返回null）；如果存在则返回value。



